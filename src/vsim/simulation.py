import logging
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from typing import Optional
from sklearn.cluster import KMeans
from voting_system import VotingSystem, ElectionResult


__all__ = ["VotingSimulator"]


class VotingSimulator:
    """
    Represents a running simulation. Runs an election given
    the injected voting system strategy and population.
    """

    def __init__(
        self,
        electorate: np.ndarray,
        n_candidates: int,
        scenario: str,
        log: logging.Logger,
        system: VotingSystem,
        plot: bool = False,
        seed: Optional[int] = None,
    ):
        # misc settings
        np.random.seed(seed)  # None means random without seed
        self.plot = plot
        self.log = log

        voters, issues = electorate.shape

        # sim params
        self.scenario = scenario
        self.voting_system: VotingSystem = system
        self.n_candidates: int = n_candidates

        # simulation agents
        self.electorate: np.ndarray = electorate
        self.candidates = self.generate_candidates()

    @property
    def n_votes(self) -> int:
        return int(self.electorate.shape[0])

    @property
    def n_issues(self) -> int:
        return int(self.electorate.shape[1])

    def generate_candidates(self) -> np.ndarray:
        """
        Candidates are generated by k-means to find centroids of the population
        This is akin to parties/candidates aligning themselves with the overall opinion
        of the population.
        """
        self.log.debug(
            f"generating candidates of size {(self.n_candidates, self.n_issues)}"
        )

        model = KMeans(n_clusters=self.n_candidates, n_init="auto").fit(self.electorate)
        return model.cluster_centers_

    def calculate_fairness(self, result: ElectionResult) -> float:
        """Fairness is calculated as the average distance to the winner"""
        avg_distances = []
        for winner in result.winners:
            avg_dist_to_winner = np.mean(
                np.linalg.norm(self.candidates[winner] - self.electorate)
            )
            avg_distances.append(avg_dist_to_winner)

        return float(np.mean(avg_distances))

    def display(self, result: ElectionResult, fairness: float):
        """Renders an election"""
        self.log.debug("displaying")
        assert self.n_issues <= 2, "can only visualise 2D elections"
        _, ax = plt.subplots()

        columns = [f"issue_{i}" for i in range(1, self.n_issues + 1)]
        electorate_df = pd.DataFrame(self.electorate, columns=columns)
        electorate_df["candidate"] = False

        # add candidates to same df to ease plotting
        candidate_df = pd.DataFrame(self.candidates, columns=columns)
        candidate_df["candidate"] = True
        df = pd.concat([electorate_df, candidate_df])

        print(df)

        sns.scatterplot(data=df, x="issue_1", y="issue_2", hue="candidate", ax=ax)
        ax.set_title(f"scenario={self.scenario}, {fairness=}")

        plt.show()

    def run(self):
        self.log.debug("running voting sim")
        result = self.voting_system.elect(self.electorate, self.candidates)
        fairness = self.calculate_fairness(result)
        print(f"fairness={fairness:.2f}")

        if self.plot:
            self.display(result, fairness)


if __name__ == "__main__":
    pass
