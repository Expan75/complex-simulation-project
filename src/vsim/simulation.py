import logging
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from typing import Optional
from sklearn.cluster import KMeans
from voting_system import VotingSystem, ElectionResult


__all__ = ["VotingSimulator"]


class VotingSimulator:
    """
    Represents a running simulation. Runs an election given
    the injected voting system strategy and population.
    """

    def __init__(
        self,
        electorate: np.ndarray,
        n_candidates: int,
        scenario: str,
        log: logging.Logger,
        system: VotingSystem,
        plot: bool = False,
        seed: Optional[int] = None,
    ):
        # misc settings
        np.random.seed(seed)  # None means random without seed
        self.plot = plot
        self.log = log

        voters, issues = electorate.shape

        # sim params
        self.scenario = scenario
        self.voting_system: VotingSystem = system
        self.n_candidates: int = n_candidates

        # simulation agents
        self.electorate: np.ndarray = electorate
        self.candidates = self.generate_candidates()

    @property
    def n_votes(self) -> int:
        return int(self.electorate.shape[0])

    @property
    def n_issues(self) -> int:
        return int(self.electorate.shape[1])

    def generate_candidates(self) -> np.ndarray:
        """
        Candidates are generated by k-means to find centroids of the population
        This is akin to parties/candidates aligning themselves with the overall opinion
        of the population.
        """
        self.log.debug(
            f"generating candidates of size {(self.n_candidates, self.n_issues)}"
        )

        model = KMeans(n_clusters=self.n_candidates, n_init="auto").fit(self.electorate)
        return model.cluster_centers_

    def generate_swedish_candidates(self) -> np.ndarray:
        """
        Generates the Swedish political parties based on: https://www.chesdata.eu/2019-chapel-hill-expert-survey
        See research folder file: CHES2019V3
        Coordinate system where x-axis is GAL-TAN and y-axis is economic right(10) and left(0)
            party	galtan	lrecon
            V	1.9411764	1.7647059
            S	4.4117646	4.1176472
            C	2.2352941	8
            L	3.2352941	7.1176472
            M	5.9411764	7.7058825
            KD	7.0588236	7.2352943
            MP	1.5882353	3.9411764
            SD	8.7647057	5.5882354
        """
        parties = np.array([[1.9411764, 1.7647059],
                        [4.4117646, 4.1176472],
                        [2.2352941, 8],
                        [3.2352941, 7.1176472],
                        [5.9411764, 7.7058825],
                        [7.0588236, 7.2352943],
                        [1.5882353, 3.9411764],
                        [8.7647057, 5.5882354]])
        return parties

    def calculate_fairness(self, result: ElectionResult) -> float:
        """Fairness is calculated as the average distance to the winner"""
        
        avg_distances = []
        for winner in result.winners:
            avg_dist_to_winner = np.mean(
                np.linalg.norm(self.candidates[winner] - self.electorate)
            )
            avg_distances.append(avg_dist_to_winner)

        return float(np.mean(avg_distances))

    def display(self, result: ElectionResult, fairness: float):
        """Renders an election"""
        self.log.debug("displaying")
        assert self.n_issues <= 2, "can only visualise 2D elections"
        _, ax = plt.subplots()

        columns = [f"issue_{i}" for i in range(1, self.n_issues + 1)]
        electorate_df = pd.DataFrame(self.electorate, columns=columns)
        electorate_df["state"] = "member of public"

        # add candidates to same df to ease plotting
        candidate_df = pd.DataFrame(self.candidates, columns=columns)
        candidate_df["state"] = "candidate"
        df = pd.concat([electorate_df, candidate_df])

        sns.scatterplot(data=df, x="issue_1", y="issue_2", hue="state", ax=ax)
        ax.set_title(f"scenario={self.scenario}, {fairness=}")

        plt.show()

    def run(self):
        self.log.debug("running voting sim")
        result = self.voting_system.elect(self.electorate, self.candidates)
        fairness = self.calculate_fairness(result)
        print(f"fairness={fairness:.2f}")

        if self.plot:
            self.display(result, fairness)


if __name__ == "__main__":
    pass
